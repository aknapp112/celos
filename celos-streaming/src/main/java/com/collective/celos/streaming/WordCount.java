package com.collective.celos.streaming;

import com.google.common.collect.Lists;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapred.TextOutputFormat;
import org.apache.spark.SparkConf;
import org.apache.spark.api.java.function.FlatMapFunction;
import org.apache.spark.api.java.function.PairFunction;
import org.apache.spark.storage.StorageLevel;
import org.apache.spark.streaming.Duration;
import org.apache.spark.streaming.api.java.JavaDStream;
import org.apache.spark.streaming.api.java.JavaPairDStream;
import org.apache.spark.streaming.api.java.JavaReceiverInputDStream;
import org.apache.spark.streaming.api.java.JavaStreamingContext;
import org.apache.spark.streaming.receiver.Receiver;
import scala.Tuple2;

import java.util.regex.Pattern;

/**
 * Custom Receiver that receives data over a socket. Received bytes is interpreted as
 * text and \n delimited lines are considered as records. They are then counted and printed.
 * <p>
 * Usage: WordCount <master> <hostname> <port>
 * <master> is the Spark master URL. In local mode, <master> should be 'local[n]' with n > 1.
 * <hostname> and <port> of the TCP server that Spark Streaming would connect to receive data.
 * <p>
 * To run this on your local machine, you need to first run a Netcat server
 * `$ nc -lk 9999`
 * and then run the example
 * `$ bin/run-example org.apache.spark.examples.streaming.WordCount localhost 9999`
 */

public class WordCount extends Receiver<String> {
    private static final Pattern SPACE = Pattern.compile(" ");

    public static void main(String[] args) {

        // Create the context with a 1 second batch size
        SparkConf sparkConf = new SparkConf().setAppName("WordCount");
//        SparkConf conf = new SparkConf().setAppName("conveyor").setMaster("local[4]");
        JavaStreamingContext ssc = new JavaStreamingContext(sparkConf, new Duration(1000));

        // Create a input stream with the custom receiver on target ip:port and count the
        // words in input stream of \n delimited text (eg. generated by 'nc')
        JavaReceiverInputDStream<String> lines = ssc.receiverStream(new WordCount());
        JavaDStream<String> words = lines.flatMap(new FlatMapFunction<String, String>() {
            @Override
            public Iterable<String> call(String x) {
                return Lists.newArrayList(SPACE.split(x));
            }
        });
        JavaPairDStream<Text, IntWritable> wordCounts = words.mapToPair(
                new PairFunction<String, String, Integer>() {
                    @Override
                    public Tuple2<String, Integer> call(String s) {
                        return new Tuple2<>(s, 1);
                    }
                }).reduceByKey((i1, i2) -> i1 + i2).mapToPair(
                new PairFunction<Tuple2<String, Integer>, Text, IntWritable>() {
                    public Tuple2<Text, IntWritable> call(Tuple2<String, Integer> e) {
                        return new Tuple2(new Text(e._1()), new IntWritable(e._2()));
                    }
                });


        class OutFormat extends TextOutputFormat<Text, IntWritable> {}

        wordCounts.saveAsHadoopFiles("hdfs://nameservice1/user/akonopko/output/test", "out", Text.class, IntWritable.class, OutFormat.class);
        ssc.start();
        ssc.awaitTermination();
    }

    // ============= Receiver code that receives data over a socket ==============

    public WordCount() {
        super(StorageLevel.MEMORY_AND_DISK_2());
    }

    public void onStart() {
        // Start the thread that receives data over a connection
        new Thread() {
            @Override
            public void run() {
                for (int i = 0; !isStopped() && i < 20; i++) {
                    String item1 = "RANDOM" + (int) (Math.random() * 10);
                    String item2 = "RANDOM" + (int) (Math.random() * 10);
                    store(item1 + " " + item2);
                }
                restart("Trying to connect again");
            }
        }.start();
    }

    public void onStop() {
        // There is nothing much to do as the thread calling receive()
        // is designed to stop by itself isStopped() returns false
    }

}
